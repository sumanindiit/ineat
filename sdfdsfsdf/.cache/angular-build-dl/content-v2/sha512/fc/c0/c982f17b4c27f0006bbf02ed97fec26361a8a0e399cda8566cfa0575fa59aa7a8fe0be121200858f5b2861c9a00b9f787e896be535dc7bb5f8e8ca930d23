{"version":3,"sources":["./node_modules/@capacitor-community/facebook-login/dist/esm/web.js","./node_modules/@codetrix-studio/capacitor-google-auth/dist/esm/web.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAA4C;AACrC,+BAA+B,yDAAS;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,yDAAyD,wDAAwD;AACjH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa,GAAG,uCAAuC;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,+B;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAA4C;AACrC,4BAA4B,yDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B","file":"web-es2015.js","sourcesContent":["import { WebPlugin } from '@capacitor/core';\nexport class FacebookLoginWeb extends WebPlugin {\n    constructor() {\n        super({\n            name: 'FacebookLogin',\n            platforms: ['web'],\n        });\n    }\n    initialize(options) {\n        const defaultOptions = { version: 'v10.0' };\n        return new Promise((resolve, reject) => {\n            try {\n                return this.loadScript(options.locale).then(() => {\n                    FB.init(Object.assign(Object.assign({}, defaultOptions), options));\n                    resolve();\n                });\n            }\n            catch (err) {\n                reject(err);\n            }\n        });\n    }\n    loadScript(locale) {\n        if (typeof document === 'undefined') {\n            return Promise.resolve();\n        }\n        const scriptId = 'fb';\n        const scriptEl = document === null || document === void 0 ? void 0 : document.getElementById(scriptId);\n        if (scriptEl) {\n            return Promise.resolve();\n        }\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        return new Promise((resolve) => {\n            script.defer = true;\n            script.async = true;\n            script.id = scriptId;\n            script.onload = () => { resolve(); };\n            script.src = `https://connect.facebook.net/${locale !== null && locale !== void 0 ? locale : 'en_US'}/sdk.js`;\n            head.appendChild(script);\n        });\n    }\n    async login(options) {\n        console.log('FacebookLoginWeb.login', options);\n        return new Promise((resolve, reject) => {\n            FB.login(response => {\n                console.debug('FB.login', response);\n                if (response.status === 'connected') {\n                    resolve({\n                        accessToken: {\n                            token: response.authResponse.accessToken,\n                        },\n                    });\n                }\n                else {\n                    reject({\n                        accessToken: {\n                            token: null,\n                        },\n                    });\n                }\n            }, { scope: options.permissions.join(',') });\n        });\n    }\n    async logout() {\n        return new Promise(resolve => {\n            FB.logout(() => resolve());\n        });\n    }\n    async getCurrentAccessToken() {\n        return new Promise((resolve, reject) => {\n            FB.getLoginStatus(response => {\n                if (response.status === 'connected') {\n                    const result = {\n                        accessToken: {\n                            applicationId: undefined,\n                            declinedPermissions: [],\n                            expires: undefined,\n                            isExpired: undefined,\n                            lastRefresh: undefined,\n                            permissions: [],\n                            token: response.authResponse.accessToken,\n                            userId: response.authResponse.userID,\n                        },\n                    };\n                    resolve(result);\n                }\n                else {\n                    reject({\n                        accessToken: {\n                            token: null,\n                        },\n                    });\n                }\n            });\n        });\n    }\n    async getProfile(options) {\n        const fields = options.fields.join(',');\n        return new Promise((resolve, reject) => {\n            FB.api('/me', { fields }, response => {\n                if (response.error) {\n                    reject(response.error.message);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    }\n}\n//# sourceMappingURL=web.js.map","import { WebPlugin } from '@capacitor/core';\nexport class GoogleAuthWeb extends WebPlugin {\n    constructor() {\n        super();\n    }\n    loadScript() {\n        if (typeof document === 'undefined') {\n            return;\n        }\n        const scriptId = 'gapi';\n        const scriptEl = document === null || document === void 0 ? void 0 : document.getElementById(scriptId);\n        if (scriptEl) {\n            return;\n        }\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.defer = true;\n        script.async = true;\n        script.id = scriptId;\n        script.onload = this.platformJsLoaded.bind(this);\n        script.src = 'https://apis.google.com/js/platform.js';\n        head.appendChild(script);\n    }\n    initialize(_options = {\n        clientId: '',\n        scopes: [],\n        grantOfflineAccess: false,\n    }) {\n        var _a, _b;\n        if (typeof window === 'undefined') {\n            return;\n        }\n        const metaClientId = (_a = document.getElementsByName('google-signin-client_id')[0]) === null || _a === void 0 ? void 0 : _a.content;\n        const clientId = _options.clientId || metaClientId || '';\n        if (!clientId) {\n            console.warn('GoogleAuthPlugin - clientId is empty');\n        }\n        this.options = {\n            clientId,\n            grantOfflineAccess: (_b = _options.grantOfflineAccess) !== null && _b !== void 0 ? _b : false,\n            scopes: _options.scopes || [],\n        };\n        this.gapiLoaded = new Promise((resolve) => {\n            // HACK: Relying on window object, can't get property in gapi.load callback\n            window.gapiResolve = resolve;\n            this.loadScript();\n        });\n        this.addUserChangeListener();\n    }\n    platformJsLoaded() {\n        gapi.load('auth2', () => {\n            const clientConfig = {\n                client_id: this.options.clientId,\n            };\n            if (this.options.scopes.length) {\n                clientConfig.scope = this.options.scopes.join(' ');\n            }\n            gapi.auth2.init(clientConfig);\n            window.gapiResolve();\n        });\n    }\n    async signIn() {\n        return new Promise(async (resolve, reject) => {\n            var _a;\n            try {\n                let serverAuthCode;\n                const needsOfflineAccess = (_a = this.options.grantOfflineAccess) !== null && _a !== void 0 ? _a : false;\n                if (needsOfflineAccess) {\n                    const offlineAccessResponse = await gapi.auth2.getAuthInstance().grantOfflineAccess();\n                    serverAuthCode = offlineAccessResponse.code;\n                }\n                else {\n                    await gapi.auth2.getAuthInstance().signIn();\n                }\n                const googleUser = gapi.auth2.getAuthInstance().currentUser.get();\n                if (needsOfflineAccess) {\n                    // HACK: AuthResponse is null if we don't do this when using grantOfflineAccess\n                    await googleUser.reloadAuthResponse();\n                }\n                const user = this.getUserFrom(googleUser);\n                user.serverAuthCode = serverAuthCode;\n                resolve(user);\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async refresh() {\n        const authResponse = await gapi.auth2.getAuthInstance().currentUser.get().reloadAuthResponse();\n        return {\n            accessToken: authResponse.access_token,\n            idToken: authResponse.id_token,\n            refreshToken: '',\n        };\n    }\n    async signOut() {\n        return gapi.auth2.getAuthInstance().signOut();\n    }\n    async addUserChangeListener() {\n        await this.gapiLoaded;\n        gapi.auth2.getAuthInstance().currentUser.listen((googleUser) => {\n            this.notifyListeners('userChange', googleUser.isSignedIn() ? this.getUserFrom(googleUser) : null);\n        });\n    }\n    getUserFrom(googleUser) {\n        const user = {};\n        const profile = googleUser.getBasicProfile();\n        user.email = profile.getEmail();\n        user.familyName = profile.getFamilyName();\n        user.givenName = profile.getGivenName();\n        user.id = profile.getId();\n        user.imageUrl = profile.getImageUrl();\n        user.name = profile.getName();\n        const authResponse = googleUser.getAuthResponse(true);\n        user.authentication = {\n            accessToken: authResponse.access_token,\n            idToken: authResponse.id_token,\n            refreshToken: '',\n        };\n        return user;\n    }\n}\n//# sourceMappingURL=web.js.map"],"sourceRoot":"webpack:///"}